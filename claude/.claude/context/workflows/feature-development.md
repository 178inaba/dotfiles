# 大規模機能開発ワークフロー

## 事前調査・要件定義フェーズ

### 1. 既存実装の徹底調査
- **類似機能の実装パターン確認**: 既存コンポーネント・API・データフローの調査
- **技術スタック整合性**: プロジェクト標準との適合性確認
- **制約条件の洗い出し**: 権限・パフォーマンス・セキュリティ要件の把握

### 2. API設計判断基準
#### 既存API拡張 vs 新規API作成
- **権限制約の有無**: 既存APIの権限設計が要件に適合するか
- **後方互換性の重要度**: 既存利用箇所への影響度
- **実装・保守コストの比較**: 開発工数・長期メンテナンス性
- **パフォーマンス要件**: 既存最適化ロジックの流用可能性

### 3. 段階的実装計画
- **Phase分けによる実装リスク分散**: 大機能を小単位に分割
- **依存関係の整理**: Backend → Frontend の順序付け
- **テスト戦略**: 各Phaseでの品質保証方針

## 設計・ドキュメント作成フェーズ

### 1. 詳細仕様書の作成基準
- **3ヶ月後判定**: 実装者が迷わず実装できるレベルの詳細度
- **実装判断の全文書化**: 技術選択の根拠・代替案・却下理由
- **コード例・参考実装**: 具体的なファイル名・行数・関数名の記載

### 2. プロジェクト管理ドキュメント構成
```
docs/
├── features/           # 機能仕様書
│   ├── images/        # UI参考画像（適切な命名）
│   └── *.md           # 詳細仕様書
├── project-management/ # 進捗管理
│   └── *-todo.md      # Phase別Todoリスト
└── api/               # API仕様書
    └── *.md           # GraphQL・REST API仕様
```

### 3. UI参考資料の整理
- **命名規則**: `{機能名}-{UI要素名}.{拡張子}`
- **配置場所**: `docs/features/images/`
- **仕様書との連携**: マークダウンリンクで参照

## 実装準備フェーズ

### 1. 複数リポジトリでの開発ブランチ管理
- **命名統一**: 同一機能で複数リポジトリに跨る場合は同じブランチ名使用
  - 例: `feature/user-detail-car-request-search-sort`
- **独立コミット**: サブモジュールでは各リポジトリで独立してコミット・プッシュ
- **ベースブランチ**: 各リポジトリの`develop`ブランチから作成

### 2. 実装ガイドラインの明文化
- **プロジェクト固有ルール**: CLAUDE.mdに実装時の必須事項を記載
- **品質基準**: ドキュメント更新・テスト実装・進捗管理の徹底
- **チーム連携**: 仕様変更時の影響範囲・連携フロー

## 実装中の品質管理

### 1. ドキュメント同期
- **仕様変更時**: 即座に詳細仕様書を更新
- **実装メモ**: `notes/`配下での技術的知見の蓄積
- **進捗可視化**: Todoリストのリアルタイム更新

### 2. コミット戦略
- **適切な粒度**: 機能単位・ファイル単位での論理的な分割
- **コミットメッセージ**: 変更内容と意図の明確な記述
- **テスト含有**: テストコードも同時にコミット

### 3. 継続的品質保証
- **各Phase完了時**: 機能テスト・性能テスト・セキュリティチェック
- **統合テスト**: 複数システム間の整合性確認
- **ドキュメント最終確認**: 実装との乖離がないかの検証

## 成功要因

### 技術面
- **既存資産の最大活用**: 車輪の再発明を避ける
- **段階的リリース**: 小さく始めて徐々に拡張
- **自動化の推進**: 手動作業の削減によるヒューマンエラー防止

### プロセス面
- **早期のフィードバック**: ステークホルダーとの密な連携
- **リスク管理**: 各Phase完了条件の明確化
- **知識共有**: チーム全体での学習・改善文化

## 注意すべき落とし穴

- **仕様の曖昧さ**: 「当然だと思った」部分の明文化不足
- **既存システムへの影響**: 意図しない副作用の見落とし
- **パフォーマンス劣化**: 大量データでの動作確認不足
- **権限・セキュリティ**: 新機能追加時の権限設計見直し不足
